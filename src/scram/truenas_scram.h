// SPDX-License-Identifier: LGPL-3.0-or-later

#ifndef _LIB_SCRAM_H_
#define _LIB_SCRAM_H_

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#include <stdint.h>
#include <stdbool.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>

#define SCRAM_MAX_ITERS 5000000
#define SCRAM_MIN_ITERS 50000
#define SCRAM_DEFAULT_ITERS 500000
#define SCRAM_NONCE_SIZE 32  /* raw bytes */
#define SCRAM_MAX_USERNAME_LEN 256

/* Error codes enum */
typedef enum {
	SCRAM_E_SUCCESS = 0,
	SCRAM_E_INVALID_REQUEST = -1,
	SCRAM_E_MEMORY_ERROR = -2,
	SCRAM_E_CRYPTO_ERROR = -3,
	SCRAM_E_BASE64_ERROR = -4,
	SCRAM_E_PARSE_ERROR = -5,
	SCRAM_E_FORMAT_ERROR = -6,
	SCRAM_E_AUTH_FAILED = -7,
	SCRAM_E_FAULT = -8
} scram_resp_t;

#define SCRAM_E_LAST SCRAM_E_FAULT

/* Error structure similar to pwenc_error_t */
typedef struct {
	char message[1024];
} scram_error_t;

/* crypto_datum_t structure - same as pwenc_datum_t */
typedef struct {
	unsigned char *data;
	size_t size;
} crypto_datum_t;

/* Macro to check if datum is valid */
#define SCRAM_DATUM_IS_VALID(d) ((d) && (d)->data && (d)->size > 0)

/* SCRAM principal (username and optional API key ID) */
typedef struct {
	uint32_t api_key_id;
	char username[SCRAM_MAX_USERNAME_LEN];
} scram_principal_t;

/* SCRAM client first message - RFC 5802 Section 5.1
 * n: This attribute specifies the name of the user whose password is
 *    used for authentication (a.k.a. "authentication identity").
 * r: This attribute specifies a sequence of random printable ASCII
 *    characters excluding ',' (which forms the nonce used by the client).
 * GS2 header: Channel binding support and authzid information.
 */
typedef struct scram_client_first_message {
	scram_principal_t principal;      /* "n:" attribute (username + optional API key ID) */
	crypto_datum_t nonce;             /* "r:" attribute (client nonce) */
	char *gs2_header;                 /* GS2 header (channel binding info) */
} scram_client_first_t;

/* SCRAM server first message - RFC 5802 Section 5.1
 * r: This attribute specifies a sequence of random printable ASCII
 *    characters excluding ',' (which forms the nonce used by the server).
 *    This is the concatenation of the nonce from the client-first-message
 *    and the nonce generated by the server.
 * s: This attribute specifies the base64-encoded salt used by the server
 *    for this user.
 * i: This attribute specifies an iteration count for the selected hash
 *    function and user.
 */
typedef struct scram_server_first_message {
	crypto_datum_t salt;              /* "s:" attribute (base64-encoded salt) */
	uint64_t iterations;              /* "i:" attribute (iteration count) */
	crypto_datum_t nonce;             /* "r:" attribute (client + server nonce combined) */
} scram_server_first_t;

/* SCRAM client final message - RFC 5802 Section 5.1
 * c: This REQUIRED attribute specifies the base64-encoded GS2 header
 *    and channel binding data. It consists of: the GS2 header from the
 *    client's first message, followed by the external channel's channel
 *    binding data, if and only if the client is using channel binding.
 * r: This attribute specifies the base64-encoded concatenation of the
 *    client nonce and server nonce (from the server-first-message).
 * p: This attribute specifies a base64-encoded ClientProof.
 */
typedef struct scram_client_final_message {
	char *gs2_header;                 /* GS2 header string (e.g., "n,,") */
	crypto_datum_t *channel_binding;  /* Raw channel binding data (not base64 encoded) */
	crypto_datum_t nonce;             /* "r:" attribute */
	crypto_datum_t client_proof;      /* "p:" attribute */
} scram_client_final_t;

/* SCRAM server final message - RFC 5802 Section 5.1
 * v: This attribute specifies a base64-encoded ServerSignature. This
 *    attribute is sent by the server in its final message, and is used
 *    by the client to verify that the server has access to the user's
 *    authentication information.
 */
typedef struct scram_server_final_message {
	crypto_datum_t signature;         /* "v:" attribute (server signature) */
} scram_server_final_t;

/* SCRAM auth data for session */
typedef struct scram_auth_data {
	crypto_datum_t salt;
	uint64_t iterations;
	crypto_datum_t salted_password;
	crypto_datum_t client_key;
	crypto_datum_t stored_key;
	crypto_datum_t server_key;
} scram_auth_data_t;


/* Core SCRAM utility functions */

/**
 * @brief Generate a cryptographically secure random nonce for SCRAM authentication
 *
 * This function generates a random nonce as specified in RFC 5802 Section 5.1.
 * The nonce is used in both client-first and server-first messages to prevent
 * replay attacks and ensure authentication freshness.
 *
 * @param[out] nonce_out - allocated crypto_datum_t containing the generated nonce
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_generate_nonce(crypto_datum_t *nonce_out, scram_error_t *error);

/**
 * @brief Perform PBKDF2 key derivation as specified in RFC 5802
 *
 * This function implements the Hi(str, salt, i) function from RFC 5802 Section 2.2.
 * It uses PBKDF2 with HMAC-SHA-512 to derive a salted password from the input key.
 * This is a core component of SCRAM authentication key generation.
 *
 * @param[in] key - input key material (typically the password or API key)
 * @param[in] salt - cryptographic salt for key derivation
 * @param[in] iterations - number of PBKDF2 iterations (must be >= SCRAM_MIN_ITERS)
 * @param[out] result - allocated crypto_datum_t containing the derived key
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_hi(const crypto_datum_t *key, const crypto_datum_t *salt,
                      uint64_t iterations, crypto_datum_t *result, scram_error_t *error);

/**
 * @brief Perform SHA-512 hash function as specified in RFC 5802
 *
 * This function implements the H(str) function from RFC 5802 Section 2.2.
 * It computes the SHA-512 hash of the input data. This is used primarily
 * for generating the stored key from the client key.
 *
 * @param[in] data - input data to hash
 * @param[out] result - allocated crypto_datum_t containing the SHA-512 hash
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_h(const crypto_datum_t *data, crypto_datum_t *result, scram_error_t *error);

/**
 * @brief Perform HMAC-SHA-512 operation as specified in RFC 5802
 *
 * This function implements HMAC-SHA-512 as referenced in RFC 5802 Section 2.2.
 * It computes the HMAC using SHA-512 hash function. This is used for generating
 * client keys, server keys, and authentication signatures in SCRAM.
 *
 * @param[in] key - HMAC key material
 * @param[in] data - data to authenticate
 * @param[out] result - allocated crypto_datum_t containing the HMAC-SHA-512 result
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_hmac_sha512(const crypto_datum_t *key, const crypto_datum_t *data,
                               crypto_datum_t *result, scram_error_t *error);

/**
 * @brief Generate the client key as specified in RFC 5802
 *
 * This function implements ClientKey generation from RFC 5802 Section 3.
 * ClientKey := HMAC(SaltedPassword, "Client Key"). The client key is used
 * to generate the client proof during authentication.
 *
 * @param[in] salted_password - the salted password derived from Hi()
 * @param[out] client_key - allocated crypto_datum_t containing the client key
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_create_client_key(const crypto_datum_t *salted_password,
                                     crypto_datum_t *client_key, scram_error_t *error);

/**
 * @brief Generate the server key as specified in RFC 5802
 *
 * This function implements ServerKey generation from RFC 5802 Section 3.
 * ServerKey := HMAC(SaltedPassword, "Server Key"). The server key is used
 * by the server to generate authentication signatures.
 *
 * @param[in] salted_password - the salted password derived from Hi()
 * @param[out] server_key - allocated crypto_datum_t containing the server key
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_create_server_key(const crypto_datum_t *salted_password,
                                     crypto_datum_t *server_key, scram_error_t *error);

/**
 * @brief Generate the stored key as specified in RFC 5802
 *
 * This function implements StoredKey generation from RFC 5802 Section 3.
 * StoredKey := H(ClientKey). The stored key is what the server stores
 * instead of the plaintext password for authentication verification.
 *
 * @param[in] client_key - the client key generated from salted password
 * @param[out] stored_key - allocated crypto_datum_t containing the stored key
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_create_stored_key(const crypto_datum_t *client_key,
                                     crypto_datum_t *stored_key, scram_error_t *error);

/**
 * @brief Create SCRAM authentication message as specified in RFC 5802
 *
 * This function creates the AuthMessage used in SCRAM authentication as defined
 * in RFC 5802 Section 3: AuthMessage := client-first-message-bare + "," +
 * server-first-message + "," + client-final-without-proof.
 *
 * @param[in] client_first_bare - client first message without GS2 header
 * @param[in] server_first_msg - complete server first message
 * @param[in] client_final_without_proof - client final message without proof
 * @param[out] auth_message - allocated crypto_datum_t containing the auth message
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_create_auth_message(const char *client_first_bare,
                                      const char *server_first_msg,
                                      const char *client_final_without_proof,
                                      crypto_datum_t *auth_message,
                                      scram_error_t *error);

/**
 * @brief Duplicate a crypto_datum_t structure
 *
 * This function creates a deep copy of a crypto_datum_t structure, allocating
 * new memory for the data buffer and copying all contents. Used throughout
 * SCRAM implementation for copying keys, nonces, and other crypto data.
 *
 * @param[in] in - source crypto_datum_t to duplicate
 * @param[out] out - destination crypto_datum_t (must be uninitialized)
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t dup_crypto_datum(const crypto_datum_t *in, crypto_datum_t *out, scram_error_t *error);

/* SCRAM client functions */

/**
 * @brief create SCRAM client first message structure
 *
 * This function creates and initializes a new scram_client_first_message
 * structure with the provided username, API key ID, and optional GS2 header.
 * It generates a random client nonce and sets up the message for the SCRAM
 * authentication handshake.
 *
 * The API key ID is stored in the principal structure and will be encoded
 * using a colon delimiter when the message is serialized.
 *
 * The function allocates a new message structure that must be freed by
 * the caller using clear_scram_client_first_message() and free().
 *
 * @param[in]		username - username for authentication
 * @param[in]		api_key_id - API key identifier (0 if not used)
 * @param[in]		gs2_header - GS2 header string (NULL for no channel binding)
 * @param[out]		msg_out - pointer to allocated message structure
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_create_client_first_message(const char *username,
					       uint32_t api_key_id,
					       const char *gs2_header,
					       scram_client_first_t **msg_out,
					       scram_error_t *error);


/**
 * @brief Create SCRAM client final message as specified in RFC 5802
 *
 * This function constructs the client-final-message for SCRAM authentication
 * as defined in RFC 5802 Section 3. It generates the client proof by calculating
 * ClientSignature = HMAC(StoredKey, AuthMessage) and ClientProof = ClientKey XOR ClientSignature.
 * The AuthMessage is constructed from client-first-message-bare, server-first-message,
 * and client-final-without-proof components.
 *
 * @param[in] channel_binding_data - optional channel binding data (can be NULL)
 * @param[in] client_key - client key derived from salted password
 * @param[in] stored_key - stored key (hash of client key)
 * @param[in] client - client first message structure
 * @param[in] server - server first message structure
 * @param[out] msg_out - allocated client final message structure
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_create_client_final_message(const crypto_datum_t *channel_binding_data,
					      const crypto_datum_t *client_key,
					      const crypto_datum_t *stored_key,
					      const scram_client_first_t *client,
					      const scram_server_first_t *server,
					      scram_client_final_t **msg_out,
					      scram_error_t *error);

/**
 * @brief Verify SCRAM client final message as specified in RFC 5802
 *
 * This function verifies the client-final-message for SCRAM authentication
 * as defined in RFC 5802 Section 3. It reconstructs the AuthMessage and
 * verifies the client proof by calculating the expected ClientSignature
 * and comparing it against the received proof.
 *
 * @param[in] cfirst - client first message structure
 * @param[in] sfirst - server first message structure
 * @param[in] cfinal - client final message to verify
 * @param[in] stored_key - stored key for verification
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on successful verification, error code on failure
 */
scram_resp_t scram_verify_client_final_message(const scram_client_first_t *cfirst,
					      const scram_server_first_t *sfirst,
					      const scram_client_final_t *cfinal,
					      const crypto_datum_t *stored_key,
					      scram_error_t *error);

/**
 * @brief Verify SCRAM server signature as specified in RFC 5802
 *
 * This function verifies the server-final-message signature for SCRAM authentication
 * as defined in RFC 5802 Section 3. It reconstructs the AuthMessage and verifies
 * the server signature by calculating the expected ServerSignature = HMAC(ServerKey, AuthMessage)
 * and comparing it against the received signature.
 *
 * @param[in] cfirst - client first message structure
 * @param[in] sfirst - server first message structure
 * @param[in] cfinal - client final message structure
 * @param[in] sfinal - server final message to verify
 * @param[in] server_key - server key for signature verification
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on successful verification, error code on failure
 */
scram_resp_t scram_verify_server_signature(const scram_client_first_t *cfirst,
					   const scram_server_first_t *sfirst,
					   const scram_client_final_t *cfinal,
					   const scram_server_final_t *sfinal,
					   const crypto_datum_t *server_key,
					   scram_error_t *error);

/* SCRAM server functions */

/**
 * @brief create SCRAM server first message structure
 *
 * This function creates and initializes a new scram_server_first_message
 * structure using the client's first message, salt, and iteration count.
 * It generates a server nonce and combines it with the client nonce,
 * then stores the provided salt and iteration count.
 *
 * The function allocates a new message structure that must be freed by
 * the caller using clear_scram_server_first_message() and free().
 *
 * @param[in]		client_msg - client first message containing nonce
 * @param[in]		salt - salt for password derivation
 * @param[in]		iterations - iteration count for PBKDF2
 * @param[out]		msg_out - pointer to allocated message structure
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_create_server_first_message(const scram_client_first_t *client_msg,
					       const crypto_datum_t *salt,
					       uint64_t iterations,
					       scram_server_first_t **msg_out,
					       scram_error_t *error);


/**
 * @brief Create SCRAM server final message as specified in RFC 5802
 *
 * This function constructs the server-final-message for SCRAM authentication
 * as defined in RFC 5802 Section 3. It generates the server signature by
 * reconstructing the AuthMessage and calculating ServerSignature = HMAC(ServerKey, AuthMessage).
 *
 * @param[in] cfirst - client first message structure
 * @param[in] sfirst - server first message structure
 * @param[in] cfinal - client final message structure
 * @param[in] stored_key - stored key for verification
 * @param[in] server_key - server key for generating server signature
 * @param[out] msg_out - allocated server final message structure
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_create_server_final_message(const scram_client_first_t *cfirst,
					      const scram_server_first_t *sfirst,
					      const scram_client_final_t *cfinal,
					      const crypto_datum_t *stored_key,
					      const crypto_datum_t *server_key,
					      scram_server_final_t **msg_out,
					      scram_error_t *error);

/* Helper functions */
/**
 * @brief Perform XOR operation on two byte arrays
 *
 * This function performs bitwise XOR between two crypto_datum_t structures
 * of equal length. Used in SCRAM for generating client proof as specified
 * in RFC 5802 Section 3: ClientProof := ClientKey XOR ClientSignature.
 *
 * @param[in] a - first byte array operand
 * @param[in] b - second byte array operand (must be same size as a)
 * @param[out] result - allocated crypto_datum_t containing the XOR result
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_xor_bytes(const crypto_datum_t *a, const crypto_datum_t *b,
                             crypto_datum_t *result, scram_error_t *error);

/**
 * @brief Perform constant-time comparison of two byte arrays
 *
 * This function compares two crypto_datum_t structures in constant time
 * to prevent timing attacks. Used in SCRAM for secure verification of
 * authentication proofs and signatures as required by security best practices.
 * Uses OpenSSL's CRYPTO_memcmp for secure constant-time comparison.
 *
 * @param[in] a - first byte array to compare
 * @param[in] b - second byte array to compare (must be same size as a)
 * @param[out] match - true if arrays are equal, false otherwise
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_constant_time_compare(const crypto_datum_t *a, const crypto_datum_t *b,
					bool *match, scram_error_t *error);

/* Base64 encoding/decoding functions */

/**
 * @brief encode binary data to base64 string
 *
 * This function encodes binary data from a crypto_datum_t structure
 * into a base64-encoded string stored in another crypto_datum_t.
 *
 * @param[in]		data_in - input binary data to encode
 * @param[out]		data_out - output base64 string (caller must free with crypto_datum_clear)
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_base64_encode(const crypto_datum_t *data_in,
				 crypto_datum_t *data_out, scram_error_t *error);

/**
 * @brief decode base64 string to binary data
 *
 * This function decodes a base64-encoded string from a crypto_datum_t
 * structure into binary data stored in another crypto_datum_t.
 *
 * @param[in]		data_in - input base64 string to decode
 * @param[out]		data_out - output binary data (caller must free with crypto_datum_clear)
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_base64_decode(const crypto_datum_t *data_in,
				 crypto_datum_t *data_out, scram_error_t *error);
/**
 * @brief free crypto_datum_t and optionally zero data
 *
 * This function frees the data buffer of a crypto_datum_t and zeros
 * the datum structure itself. If zero_data is true, the data buffer
 * is securely zeroed before being freed.
 *
 * It is safe to call this function with a NULL or already-cleared datum.
 *
 * @param[in,out]	datum - pointer to datum to clear
 * @param[in]		zero_data - if true, zero data buffer before freeing
 */
void crypto_datum_clear(crypto_datum_t *datum, bool zero_data);

/* Convert raw API key to SCRAM data */
int raw_api_key_to_scram_data(const char *api_key, const crypto_datum_t *salt,
                              uint64_t iterations, crypto_datum_t *client_key_out,
                              crypto_datum_t *stored_key_out, crypto_datum_t *server_key_out);

/**
 * @brief Generate SCRAM authentication data from optional inputs
 *
 * This function generates complete SCRAM authentication data including client key,
 * stored key, and server key. It can generate missing components automatically:
 * - If salted_password is NULL, generates from 64 random bytes
 * - If salt is NULL and salted_password is NULL, generates 16 random bytes for salt
 * - If iterations is 0 and salted_password is NULL, defaults to SCRAM_DEFAULT_ITERS (500000)
 *
 * Important constraints:
 * - If salted_password is provided, salt and iterations MUST match what was used to generate it
 * - salted_password provided without salt or iterations is invalid
 *
 * @param[in] salted_password - optional pre-computed salted password (can be NULL)
 * @param[in] salt - salt used for PBKDF2 (required if salted_password provided, can be NULL otherwise)
 * @param[in] iterations - PBKDF2 iterations (required if salted_password provided, 0 for default otherwise)
 * @param[out] auth_data_out - allocated scram_auth_data structure
 * @param[in,out] error - error buffer for detailed error information
 * @return SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t generate_scram_auth_data(const crypto_datum_t *salted_password,
                                     const crypto_datum_t *salt,
                                     uint64_t iterations,
                                     scram_auth_data_t *auth_data_out,
                                     scram_error_t *error);

/* SCRAM Message Serialization/Deserialization Functions */

/**
 * @brief serialize SCRAM client first message to RFC 5802 format
 *
 * This function serializes a scram_client_first_message structure into
 * a string conforming to RFC 5802. When bare is true, produces the
 * client-first-message-bare format (without GS2 header). When bare is
 * false, produces the full client-first-message format (with GS2 header).
 *
 * The API key ID is encoded using a colon delimiter after the username
 * when present (non-zero).
 *
 * @param[in]		msg - pointer to client first message structure
 * @param[out]		scram_msg_str_out - pointer to output string (caller must free)
 * @param[in]		bare - if true, omit GS2 header (client-first-message-bare)
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_serialize_client_first_message(const scram_client_first_t *msg,
						  char **scram_msg_str_out,
						  bool bare, scram_error_t *error);

/**
 * @brief deserialize SCRAM client first message from RFC 5802 format
 *
 * This function deserializes a string conforming to RFC 5802 into
 * a scram_client_first_message structure. It handles both full
 * client-first-message format (with GS2 header) and client-first-
 * message-bare format (without GS2 header).
 *
 * The API key ID is decoded using a colon delimiter after the username
 * when present.
 *
 * The function allocates a new message structure that must be freed
 * by the caller using clear_scram_client_first_message() and free().
 *
 * @param[in]		scram_msg_str - RFC 5802 formatted message string
 * @param[out]		msg_out - pointer to output message structure
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_deserialize_client_first_message(const char *scram_msg_str,
						    scram_client_first_t **msg_out,
						    scram_error_t *error);

/**
 * @brief serialize SCRAM server first message to RFC 5802 format
 *
 * This function serializes a scram_server_first_message structure into
 * a string conforming to RFC 5802. The server-first-message format is:
 * r=<combined_nonce>,s=<salt>,i=<iteration_count>
 *
 * The nonce and salt are base64-encoded in the output string.
 *
 * @param[in]		msg - pointer to server first message structure
 * @param[out]		scram_msg_str_out - pointer to output string (caller must free)
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_serialize_server_first_message(const scram_server_first_t *msg,
						  char **scram_msg_str_out,
						  scram_error_t *error);

/**
 * @brief deserialize SCRAM server first message from RFC 5802 format
 *
 * This function deserializes a string conforming to RFC 5802 into
 * a scram_server_first_message structure. The expected format is:
 * r=<combined_nonce>,s=<salt>,i=<iteration_count>
 *
 * The function validates the attribute order and iteration count range.
 * The nonce and salt are base64-decoded from the input string.
 *
 * The function allocates a new message structure that must be freed
 * by the caller using clear_scram_server_first_message() and free().
 *
 * @param[in]		scram_msg_str - RFC 5802 formatted message string
 * @param[out]		msg_out - pointer to allocated message structure
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_deserialize_server_first_message(const char *scram_msg_str,
						    scram_server_first_t **msg_out,
						    scram_error_t *error);

/**
 * @brief serialize SCRAM client final message to RFC 5802 format
 *
 * This function serializes a scram_client_final_message structure into
 * a string conforming to RFC 5802. The client-final-message format is:
 * c=<base64_channel_binding>,r=<nonce>,p=<client_proof>
 *
 * The channel binding (GS2 header) is base64-encoded. If no GS2 header
 * is provided, defaults to "n,," (no channel binding support).
 *
 * @param[in]		msg - pointer to client final message structure
 * @param[out]		scram_msg_str_out - pointer to output string (caller must free)
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_serialize_client_final_message(scram_client_final_t *msg,
						  char **scram_msg_str_out,
						  scram_error_t *error);

/**
 * @brief deserialize SCRAM client final message from RFC 5802 format
 *
 * This function deserializes a string conforming to RFC 5802 into
 * a scram_client_final_message structure. The expected format is:
 * c=<base64_channel_binding>,r=<nonce>,p=<client_proof>
 *
 * The channel binding is base64-decoded back to the GS2 header string.
 * The function validates the attribute order and decodes all base64 data.
 *
 * The function allocates a new message structure that must be freed
 * by the caller using clear_scram_client_final_message() and free().
 *
 * @param[in]		scram_msg_str - RFC 5802 formatted message string
 * @param[out]		msg_out - pointer to allocated message structure
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_deserialize_client_final_message(const char *scram_msg_str,
						    scram_client_final_t **msg_out,
						    scram_error_t *error);

/**
 * @brief serialize SCRAM server final message to RFC 5802 format
 *
 * This function serializes a scram_server_final_message structure into
 * a string conforming to RFC 5802. The server-final-message format is:
 * v=<server_signature>
 *
 * The server signature is base64-encoded in the output string.
 *
 * @param[in]		msg - pointer to server final message structure
 * @param[out]		scram_msg_str_out - pointer to output string (caller must free)
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_serialize_server_final_message(const scram_server_final_t *msg,
						  char **scram_msg_str_out,
						  scram_error_t *error);

/**
 * @brief deserialize SCRAM server final message from RFC 5802 format
 *
 * This function deserializes a string conforming to RFC 5802 into
 * a scram_server_final_message structure. The expected format is:
 * v=<server_signature>
 *
 * The server signature is base64-decoded from the input string.
 * The function validates that only the signature attribute is present.
 *
 * The function allocates a new message structure that must be freed
 * by the caller using clear_scram_server_final_message() and free().
 *
 * @param[in]		scram_msg_str - RFC 5802 formatted message string
 * @param[out]		msg_out - pointer to allocated message structure
 * @param[in,out]	error - error buffer for detailed error information
 * @return		SCRAM_E_SUCCESS on success, error code on failure
 */
scram_resp_t scram_deserialize_server_final_message(const char *scram_msg_str,
						    scram_server_final_t **msg_out,
						    scram_error_t *error);

/* Memory management */
void clear_scram_auth_data(scram_auth_data_t *auth_data);
void clear_scram_client_first_message(struct scram_client_first_message *msg);
void clear_scram_server_first_message(scram_server_first_t *msg);
void clear_scram_client_final_message(scram_client_final_t *msg);
void clear_scram_server_final_message(scram_server_final_t *msg);

#endif /* _LIB_SCRAM_H_ */
